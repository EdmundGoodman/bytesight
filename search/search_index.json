{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"ByteSight","text":"<p>A novel performance profiler operating at the bytecode level for the CPython interpreter.</p> <p>Read more about it in chapter four of my Master\u2019s thesis.</p>"},{"location":"reference.html","title":"Reference","text":""},{"location":"reference.html#bytesight.main","title":"<code>main</code>","text":"<p>Bytesight tracing profiler for Python bytecode.</p>"},{"location":"reference.html#bytesight.main.print_bytecode","title":"<code>print_bytecode(func: Callable[[], Any], *args: list[Any], **kwargs: dict[str, Any]) -&gt; None</code>","text":"<p>Print the bytecode executed when running a function.</p> <p>The function must be pure, as it is run many times to get various peices of data.</p> Source code in <code>src/bytesight/main.py</code> <pre><code>def print_bytecode(\n    func: Callable[[], Any],\n    *args: list[Any],\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Print the bytecode executed when running a function.\n\n    The function must be pure, as it is run many times to get various peices of\n    data.\n    \"\"\"\n    profiler = BytecodeProfiler(num_warmups=0, num_repeats=0)\n    profiler.profile(func, *args, **kwargs)\n    BytecodeProfiler.print_events(\n        events=profiler.events,\n        trace_name=func.__qualname__,\n        elapsed_times=None,\n    )\n</code></pre>"},{"location":"reference.html#bytesight.main.profile_bytecode","title":"<code>profile_bytecode(func: Callable[[], Any], *args: list[Any], **kwargs: dict[str, Any]) -&gt; None</code>","text":"<p>Profile the bytecode executed when running a function.</p> <p>The function must be pure, as it is run many times to get various peices of data.</p> Source code in <code>src/bytesight/main.py</code> <pre><code>def profile_bytecode(\n    func: Callable[[], Any],\n    *args: list[Any],\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Profile the bytecode executed when running a function.\n\n    The function must be pure, as it is run many times to get various peices of\n    data.\n    \"\"\"\n    profiler = BytecodeProfiler()\n    profiler.profile(func, *args, **kwargs)\n    elapsed_times = profiler.calculate_trace_times()\n\n    BytecodeProfiler.print_events(\n        events=profiler.events,\n        trace_name=func.__qualname__,\n        elapsed_times=elapsed_times,\n    )\n</code></pre>"},{"location":"reference.html#bytesight.main.main","title":"<code>main() -&gt; None</code>","text":"<p>Invoke the bytecode profiler.</p> Source code in <code>src/bytesight/main.py</code> <pre><code>def main() -&gt; None:  # pragma: no cover\n    \"\"\"Invoke the bytecode profiler.\"\"\"\n    raise NotImplementedError(\"CLI not yet implemented!\")\n</code></pre>"},{"location":"reference.html#bytesight.events","title":"<code>events</code>","text":"<p>Data structures representing trace events.</p>"},{"location":"reference.html#bytesight.events.StopEvent","title":"<code>StopEvent</code>  <code>dataclass</code>","text":"<p>An event guarding the end of the trace.</p> Source code in <code>src/bytesight/events.py</code> <pre><code>@dataclass(eq=True, frozen=True)\nclass StopEvent:\n    \"\"\"An event guarding the end of the trace.\"\"\"\n\n    exception: Exception | None\n</code></pre>"},{"location":"reference.html#bytesight.events.TracedEvent","title":"<code>TracedEvent</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An event in a trace, having both a current and previous timestamp.</p> Source code in <code>src/bytesight/events.py</code> <pre><code>@dataclass(eq=True, frozen=True)\nclass TracedEvent(abc.ABC):\n    \"\"\"An event in a trace, having both a current and previous timestamp.\"\"\"\n\n    @classmethod\n    @abc.abstractmethod\n    def from_frame(\n        cls,\n        frame: types.FrameType,\n        arg: Any,\n    ) -&gt; \"TracedEvent\": ...\n</code></pre>"},{"location":"reference.html#bytesight.events.CallEvent","title":"<code>CallEvent</code>  <code>dataclass</code>","text":"<p>               Bases: <code>TracedEvent</code></p> <p>A call event in a trace.</p> Source code in <code>src/bytesight/events.py</code> <pre><code>@dataclass(eq=True, frozen=True)\nclass CallEvent(TracedEvent):\n    \"\"\"A call event in a trace.\"\"\"\n\n    name: str\n    file: Path\n    lineno: int | None\n\n    @classmethod\n    def get_name(cls, frame: types.FrameType) -&gt; str:\n        \"\"\"Get the name of a function.\"\"\"\n        if sys.version_info.minor &lt;= 10:\n            return frame.f_code.co_name\n        return frame.f_code.co_qualname\n\n    @classmethod\n    def from_frame(\n        cls,\n        frame: types.FrameType,\n        arg: None,\n    ) -&gt; \"CallEvent\":\n        \"\"\"Construct the representation from a frame object.\"\"\"\n        return cls(\n            name=cls.get_name(frame),\n            file=Path(frame.f_code.co_filename),\n            lineno=frame.f_code.co_firstlineno,\n        )\n</code></pre>"},{"location":"reference.html#bytesight.events.CallEvent.get_name","title":"<code>get_name(frame: types.FrameType) -&gt; str</code>  <code>classmethod</code>","text":"<p>Get the name of a function.</p> Source code in <code>src/bytesight/events.py</code> <pre><code>@classmethod\ndef get_name(cls, frame: types.FrameType) -&gt; str:\n    \"\"\"Get the name of a function.\"\"\"\n    if sys.version_info.minor &lt;= 10:\n        return frame.f_code.co_name\n    return frame.f_code.co_qualname\n</code></pre>"},{"location":"reference.html#bytesight.events.CallEvent.from_frame","title":"<code>from_frame(frame: types.FrameType, arg: None) -&gt; CallEvent</code>  <code>classmethod</code>","text":"<p>Construct the representation from a frame object.</p> Source code in <code>src/bytesight/events.py</code> <pre><code>@classmethod\ndef from_frame(\n    cls,\n    frame: types.FrameType,\n    arg: None,\n) -&gt; \"CallEvent\":\n    \"\"\"Construct the representation from a frame object.\"\"\"\n    return cls(\n        name=cls.get_name(frame),\n        file=Path(frame.f_code.co_filename),\n        lineno=frame.f_code.co_firstlineno,\n    )\n</code></pre>"},{"location":"reference.html#bytesight.events.LineEvent","title":"<code>LineEvent</code>  <code>dataclass</code>","text":"<p>               Bases: <code>TracedEvent</code></p> <p>A call event in a trace.</p> Source code in <code>src/bytesight/events.py</code> <pre><code>@dataclass(eq=True, frozen=True)\nclass LineEvent(TracedEvent):\n    \"\"\"A call event in a trace.\"\"\"\n\n    contents: str\n\n    @classmethod\n    def from_frame(\n        cls,\n        frame: types.FrameType,\n        arg: None,\n    ) -&gt; \"LineEvent\":\n        \"\"\"Construct the representation from a frame object.\"\"\"\n        try:\n            frameinfo = inspect.getframeinfo(frame)\n            code_context = frameinfo.code_context\n            assert code_context is not None\n            contents = code_context[0].strip()\n        except Exception:\n            contents = \"&lt;source not available&gt;\"\n\n        return cls(\n            contents=contents,\n        )\n</code></pre>"},{"location":"reference.html#bytesight.events.LineEvent.from_frame","title":"<code>from_frame(frame: types.FrameType, arg: None) -&gt; LineEvent</code>  <code>classmethod</code>","text":"<p>Construct the representation from a frame object.</p> Source code in <code>src/bytesight/events.py</code> <pre><code>@classmethod\ndef from_frame(\n    cls,\n    frame: types.FrameType,\n    arg: None,\n) -&gt; \"LineEvent\":\n    \"\"\"Construct the representation from a frame object.\"\"\"\n    try:\n        frameinfo = inspect.getframeinfo(frame)\n        code_context = frameinfo.code_context\n        assert code_context is not None\n        contents = code_context[0].strip()\n    except Exception:\n        contents = \"&lt;source not available&gt;\"\n\n    return cls(\n        contents=contents,\n    )\n</code></pre>"},{"location":"reference.html#bytesight.events.ReturnEvent","title":"<code>ReturnEvent</code>  <code>dataclass</code>","text":"<p>               Bases: <code>TracedEvent</code></p> <p>A call event in a trace.</p> Source code in <code>src/bytesight/events.py</code> <pre><code>@dataclass(eq=True, frozen=True)\nclass ReturnEvent(TracedEvent):\n    \"\"\"A call event in a trace.\"\"\"\n\n    return_value: Any\n\n    @classmethod\n    def from_frame(\n        cls,\n        frame: types.FrameType,\n        arg: None,\n    ) -&gt; \"ReturnEvent\":\n        \"\"\"Construct the representation from a frame object.\"\"\"\n        return cls(return_value=arg)\n</code></pre>"},{"location":"reference.html#bytesight.events.ReturnEvent.from_frame","title":"<code>from_frame(frame: types.FrameType, arg: None) -&gt; ReturnEvent</code>  <code>classmethod</code>","text":"<p>Construct the representation from a frame object.</p> Source code in <code>src/bytesight/events.py</code> <pre><code>@classmethod\ndef from_frame(\n    cls,\n    frame: types.FrameType,\n    arg: None,\n) -&gt; \"ReturnEvent\":\n    \"\"\"Construct the representation from a frame object.\"\"\"\n    return cls(return_value=arg)\n</code></pre>"},{"location":"reference.html#bytesight.events.ExceptionEvent","title":"<code>ExceptionEvent</code>  <code>dataclass</code>","text":"<p>               Bases: <code>TracedEvent</code></p> <p>A call event in a trace.</p> Source code in <code>src/bytesight/events.py</code> <pre><code>@dataclass(eq=True, frozen=True)\nclass ExceptionEvent(TracedEvent):\n    \"\"\"A call event in a trace.\"\"\"\n\n    exception: type\n    value: Exception = field(compare=False)\n    traceback: types.TracebackType | None = field(compare=False)\n\n    @classmethod\n    def from_frame(\n        cls,\n        frame: types.FrameType,\n        arg: tuple[type, Exception, types.TracebackType | None],\n    ) -&gt; \"ExceptionEvent\":\n        \"\"\"Construct the representation from a frame object.\"\"\"\n        return cls(\n            exception=arg[0],\n            value=arg[1],\n            traceback=arg[2],\n        )\n</code></pre>"},{"location":"reference.html#bytesight.events.ExceptionEvent.from_frame","title":"<code>from_frame(frame: types.FrameType, arg: tuple[type, Exception, types.TracebackType | None]) -&gt; ExceptionEvent</code>  <code>classmethod</code>","text":"<p>Construct the representation from a frame object.</p> Source code in <code>src/bytesight/events.py</code> <pre><code>@classmethod\ndef from_frame(\n    cls,\n    frame: types.FrameType,\n    arg: tuple[type, Exception, types.TracebackType | None],\n) -&gt; \"ExceptionEvent\":\n    \"\"\"Construct the representation from a frame object.\"\"\"\n    return cls(\n        exception=arg[0],\n        value=arg[1],\n        traceback=arg[2],\n    )\n</code></pre>"},{"location":"reference.html#bytesight.events.OpcodeEvent","title":"<code>OpcodeEvent</code>  <code>dataclass</code>","text":"<p>               Bases: <code>TracedEvent</code></p> <p>A call event in a trace.</p> Source code in <code>src/bytesight/events.py</code> <pre><code>@dataclass(eq=True, frozen=True)\nclass OpcodeEvent(TracedEvent):\n    \"\"\"A call event in a trace.\"\"\"\n\n    lineno: int | None\n    curr_instr: bool\n    jump: bool\n    offset: int\n    opname: str\n    arg: int | None\n    argrepr: str\n\n    @classmethod\n    def get_opcode(cls, frame: types.FrameType) -&gt; dis.Instruction | None:\n        \"\"\"Get the current opcode name for a frame.\n\n        This can be found by retrieving the instruction at the correct offset in\n        the frame.\n        \"\"\"\n        if sys.version_info.minor &gt;= 11:\n            instructions = dis.get_instructions(frame.f_code, adaptive=USE_ADAPTIVE)\n        else:\n            instructions = dis.get_instructions(frame.f_code)\n        for instr in instructions:\n            if instr.offset == frame.f_lasti:\n                return instr\n        return None\n\n    @classmethod\n    def get_lineno(cls, instruction: dis.Instruction) -&gt; int | None:\n        \"\"\"Get the line number for an instruction.\"\"\"\n        if sys.version_info.minor &lt;= 11:\n            return instruction.starts_line\n        if instruction.line_number is not None:\n            return instruction.line_number\n        return getattr(instruction.positions, \"lineno\", None)\n\n    @classmethod\n    def from_frame(\n        cls,\n        frame: types.FrameType,\n        arg: None,\n    ) -&gt; \"OpcodeEvent\":\n        \"\"\"Construct the representation from a frame object.\"\"\"\n        instruction = cls.get_opcode(frame)\n        assert instruction is not None\n\n        # TODO: `OpcodeEvent` could just store the instruction and make these properties?\n        return cls(\n            lineno=cls.get_lineno(instruction),\n            curr_instr=False,\n            jump=instruction.is_jump_target,\n            offset=instruction.offset,\n            opname=instruction.opname,\n            arg=instruction.arg,\n            argrepr=instruction.argrepr,\n        )\n</code></pre>"},{"location":"reference.html#bytesight.events.OpcodeEvent.get_opcode","title":"<code>get_opcode(frame: types.FrameType) -&gt; dis.Instruction | None</code>  <code>classmethod</code>","text":"<p>Get the current opcode name for a frame.</p> <p>This can be found by retrieving the instruction at the correct offset in the frame.</p> Source code in <code>src/bytesight/events.py</code> <pre><code>@classmethod\ndef get_opcode(cls, frame: types.FrameType) -&gt; dis.Instruction | None:\n    \"\"\"Get the current opcode name for a frame.\n\n    This can be found by retrieving the instruction at the correct offset in\n    the frame.\n    \"\"\"\n    if sys.version_info.minor &gt;= 11:\n        instructions = dis.get_instructions(frame.f_code, adaptive=USE_ADAPTIVE)\n    else:\n        instructions = dis.get_instructions(frame.f_code)\n    for instr in instructions:\n        if instr.offset == frame.f_lasti:\n            return instr\n    return None\n</code></pre>"},{"location":"reference.html#bytesight.events.OpcodeEvent.get_lineno","title":"<code>get_lineno(instruction: dis.Instruction) -&gt; int | None</code>  <code>classmethod</code>","text":"<p>Get the line number for an instruction.</p> Source code in <code>src/bytesight/events.py</code> <pre><code>@classmethod\ndef get_lineno(cls, instruction: dis.Instruction) -&gt; int | None:\n    \"\"\"Get the line number for an instruction.\"\"\"\n    if sys.version_info.minor &lt;= 11:\n        return instruction.starts_line\n    if instruction.line_number is not None:\n        return instruction.line_number\n    return getattr(instruction.positions, \"lineno\", None)\n</code></pre>"},{"location":"reference.html#bytesight.events.OpcodeEvent.from_frame","title":"<code>from_frame(frame: types.FrameType, arg: None) -&gt; OpcodeEvent</code>  <code>classmethod</code>","text":"<p>Construct the representation from a frame object.</p> Source code in <code>src/bytesight/events.py</code> <pre><code>@classmethod\ndef from_frame(\n    cls,\n    frame: types.FrameType,\n    arg: None,\n) -&gt; \"OpcodeEvent\":\n    \"\"\"Construct the representation from a frame object.\"\"\"\n    instruction = cls.get_opcode(frame)\n    assert instruction is not None\n\n    # TODO: `OpcodeEvent` could just store the instruction and make these properties?\n    return cls(\n        lineno=cls.get_lineno(instruction),\n        curr_instr=False,\n        jump=instruction.is_jump_target,\n        offset=instruction.offset,\n        opname=instruction.opname,\n        arg=instruction.arg,\n        argrepr=instruction.argrepr,\n    )\n</code></pre>"},{"location":"reference.html#bytesight.profiler","title":"<code>profiler</code>","text":"<p>Implementation of the profiler.</p>"},{"location":"reference.html#bytesight.profiler.BytecodeProfiler","title":"<code>BytecodeProfiler</code>  <code>dataclass</code>","text":"<p>A profiler for Python (&gt;=3.7) bytecode.</p> Source code in <code>src/bytesight/profiler.py</code> <pre><code>@dataclass\nclass BytecodeProfiler:\n    \"\"\"A profiler for Python (&gt;=3.7) bytecode.\"\"\"\n\n    num_warmups: int = FUNC_WARMUPS\n    num_repeats: int = FUNC_REPEATS\n    debug: bool = True\n\n    _events: list[TracedEvent | StopEvent] = field(default_factory=list)\n    _timestamps: list[EventTimestamp] = field(default_factory=list)\n    _uninstrumented_time: float | None = None\n    _instrumented_time: float | None = None\n    _prev_event_timestamp: float | None = None\n\n    _opcode_overhead: float = 0.0\n\n    @property\n    def events(self) -&gt; list[TracedEvent | StopEvent]:\n        return self._events\n\n    @property\n    def uninstrumented_time(self) -&gt; float | None:\n        return self._uninstrumented_time\n\n    @property\n    def instrumented_time(self) -&gt; float | None:\n        return self._instrumented_time\n\n    def _reset(self) -&gt; None:\n        \"\"\"Reset the profiler.\"\"\"\n        self._events = []\n        self._timestamps = []\n        self._prev_event_timestamp = None\n        self._uninstrumented_time = None\n        self._instrumented_time = None\n\n    def _trace__collect_event_timestamps(\n        self, frame: types.FrameType, event: str, _arg: Any\n    ) -&gt; Callable[..., Any] | None:\n        \"\"\"Trace function which does nothing.\"\"\"\n        now_timestamp = perf_counter()\n        frame.f_trace_lines = False\n        frame.f_trace_opcodes = True\n\n        if event == \"opcode\":\n            self._timestamps.append(\n                (\n                    self._prev_event_timestamp,\n                    now_timestamp,\n                )\n            )\n            self._prev_event_timestamp = perf_counter()\n\n        return self._trace__collect_event_timestamps\n\n    def _trace__collect_all_events(\n        self, frame: types.FrameType, event: str, arg: Any\n    ) -&gt; Callable[..., Any] | None:\n        \"\"\"Collect all events emitted by the function being traced.\"\"\"\n        frame.f_trace_lines = True\n        frame.f_trace_opcodes = True\n\n        assert event in EVENT_NAME_LOOKUP\n        self._events.append(\n            EVENT_NAME_LOOKUP[event].from_frame(\n                frame=frame,\n                arg=arg,\n            )\n        )\n\n        return self._trace__collect_all_events\n\n    def profile(\n        self, func: Callable[..., Any], *args: list[Any], **kwargs: dict[str, Any]\n    ) -&gt; None:\n        \"\"\"Collect all events emitted when invoking a function.\"\"\"\n        if PYTHON_VERSION.minor &lt; 10:\n            raise RuntimeError(\"Tracing only supported for Python versions &gt;=3.10!\")\n\n        self._reset()\n\n        old_trace = sys.gettrace()\n        gcold = gc.isenabled()\n        gc.disable()\n\n        exception = None\n        try:\n            # Warmup cache/specialising adaptive interpreter/JIT\n            for _ in range(self.num_warmups):\n                try:\n                    func(*args, **kwargs)\n                except Exception as _exc:\n                    pass\n\n            # Measure the time taken to run the function once without tracing\n            self._uninstrumented_time = 0\n            for _ in range(self.num_repeats):\n                start_timestamp: float | None = None\n                try:\n                    start_timestamp = perf_counter()\n                    func(*args, **kwargs)\n                    finish_timestamp = perf_counter()\n                except Exception as _exc:\n                    finish_timestamp = perf_counter()\n                assert start_timestamp is not None\n                self._uninstrumented_time += finish_timestamp - start_timestamp\n            if self.num_repeats != 0:\n                self._uninstrumented_time /= self.num_repeats\n\n            # Trace the function collecting the event data to corrollate\n            try:\n                sys.settrace(self._trace__collect_all_events)\n                func(*args, **kwargs)\n            except Exception as exc:\n                exception = exc\n            finally:\n                sys.settrace(None)\n            self._events.append(StopEvent(exception))\n\n            # Trace the function collecting only the timestamps\n            instrumented_time_repeats: list[float] = []\n            for _ in range(self.num_repeats):\n                start_timestamp: float | None = None\n                try:\n                    sys.settrace(self._trace__collect_event_timestamps)\n                    start_timestamp = perf_counter()\n                    func(*args, **kwargs)\n                    finish_timestamp = perf_counter()\n                except Exception as _exc:\n                    finish_timestamp = perf_counter()\n                finally:\n                    sys.settrace(None)\n                self._timestamps.append((self._prev_event_timestamp, finish_timestamp))\n                assert start_timestamp is not None\n                instrumented_time_repeats.append(finish_timestamp - start_timestamp)\n            if self.num_repeats != 0:\n                self._instrumented_time = statistics.mean(instrumented_time_repeats)\n\n        finally:\n            if gcold:\n                gc.enable()\n            sys.settrace(old_trace)\n            opcode_events = [\n                e\n                for e in self._events\n                if isinstance(e, OpcodeEvent) or isinstance(e, StopEvent)\n            ]\n            assert len(opcode_events) * self.num_repeats == len(self._timestamps)\n\n    @classmethod\n    def get_nop_sled(cls, size: int) -&gt; Callable[..., None]:\n        \"\"\"Get a function which is a nop sled for baseline profiling.\"\"\"\n        many_passes = \"\\n    \".join(\"pass\" for _ in range(size))\n        namespace: dict[str, Any] = {}\n        exec(f\"def nop_sled():\\n    {many_passes}\", {}, namespace)\n        return namespace[\"nop_sled\"]\n\n    def calibrate_opcode_overhead(self, num_opcodes: int = 1000) -&gt; None:\n        \"\"\"Calibrate opcode tracing overhead by tracing many NOP opcodes.\"\"\"\n        nop_sled = self.get_nop_sled(num_opcodes)\n        self.profile(nop_sled)\n        assert self._uninstrumented_time is not None\n        assert self._instrumented_time is not None\n        assert len(self._events)\n        assert isinstance(self._events[-1], StopEvent)\n        assert self._events[-1].exception is None\n\n        elapsed_times = self.calculate_elapsed_times()\n        self._opcode_overhead = (sum(elapsed_times) - self._uninstrumented_time) / len(\n            elapsed_times\n        )\n\n        self._reset()\n\n    def calculate_elapsed_times(self) -&gt; list[float]:\n        \"\"\"Calculate the elapsed time for each event.\"\"\"\n        timestamp_repeats: list[list[EventTimestamp]] = []\n        opcode_events = [\n            e\n            for e in self._events\n            if isinstance(e, OpcodeEvent) or isinstance(e, StopEvent)\n        ]\n        for i in range(0, len(self._timestamps), len(opcode_events)):\n            timestamp_repeats.append(self._timestamps[i : i + len(opcode_events)])\n\n        elapsed_time_repeats: list[list[float]] = []\n        for timestamps in timestamp_repeats:\n            elapsed_times: list[float] = [0.0 for _ in range(len(timestamps))]\n            for i, timestamp in enumerate(timestamps):\n                if i == 0:\n                    continue\n                assert (start_execution_timestamp := timestamp[0]) is not None\n                assert (end_execution_timestamp := timestamp[1]) is not None\n                elapsed_times[i - 1] = (\n                    end_execution_timestamp\n                    - start_execution_timestamp\n                    - self._opcode_overhead\n                )\n            elapsed_time_repeats.append(elapsed_times)\n\n        elapsed_times = [\n            # statistics.mean(event_elapsed_times)\n            min(event_elapsed_times)\n            for event_elapsed_times in zip(*elapsed_time_repeats, strict=False)\n        ]\n\n        if self.debug:\n            assert self._uninstrumented_time is not None\n            assert self._instrumented_time is not None\n            print(\"===========================================\")\n            print(f\" Events recorded: {len(self.events)}\")\n            print(f\" Opcodes recorded: {len(elapsed_times)}\")\n            print(f\" Uninstrumented: {self._uninstrumented_time * NS_PER_S:.2f} ns\")\n            print(\n                f\" Uninstrumented per opcode: {(self._uninstrumented_time / len(elapsed_times)) * NS_PER_S:.2f} ns/op\"\n            )\n            print(f\" Instrumented: {self._instrumented_time * NS_PER_S:.2f} ns\")\n            print(\n                f\" Instrumented per opcode: {(self._instrumented_time / len(elapsed_times)) * NS_PER_S:.2f} ns/op\"\n            )\n            print(f\" Elapsed: {sum(elapsed_times) * NS_PER_S:.2f} ns\")\n            print(\n                f\" Elapsed per opcode: {statistics.mean(elapsed_times) * NS_PER_S:.2f} ns/op\"\n            )\n            print(f\" Opcode overhead: {self._opcode_overhead * NS_PER_S:.2f} ns/op\")\n            tracing_overhead = (sum(elapsed_times) - self._uninstrumented_time) / len(\n                elapsed_times\n            )\n            print(\n                f\" Tracing overhead per opcode: {tracing_overhead * NS_PER_S:.2f} ns/op\"\n            )\n            print(\"===========================================\", end=\"\\n\\n\")\n\n        return elapsed_times\n\n    def calculate_trace_times(self) -&gt; list[float]:\n        \"\"\"Calculate the trace time for each event.\"\"\"\n        elapsed_times = self.calculate_elapsed_times()\n        assert self.uninstrumented_time is not None\n        scaling_factor = self.uninstrumented_time / sum(elapsed_times)\n        return [elapsed_time * scaling_factor for elapsed_time in elapsed_times]\n\n    @classmethod\n    def print_events(\n        cls,\n        events: list[Any],\n        trace_name: str,\n        elapsed_times: list[float] | None = None,\n        indent_size: int = 4,\n        debug: bool = True,\n    ) -&gt; None:\n        \"\"\"Print a string representation of the traced events.\"\"\"\n        if elapsed_times is not None:\n            assert len(\n                [\n                    e\n                    for e in events\n                    if isinstance(e, OpcodeEvent) or isinstance(e, StopEvent)\n                ]\n            ) == len(elapsed_times)\n\n        print(f\"//// Trace of `{trace_name}` :\")\n        indent = -indent_size\n        elapsed_time_index = 0\n        for i, event in enumerate(events):\n            if isinstance(event, CallEvent):\n                indent += indent_size\n                contents = f\" {event.file.stem}:{event.lineno} `{event.name}` \"\n                print(\n                    f\"\\n{' ' * indent}// =={contents:{'='}{'^'}{FUNCTION_DELIMITER_LENGTH - 4}}==\"\n                )\n            elif isinstance(event, LineEvent):\n                print(f\"{' ' * indent}// &gt;&gt;&gt; {event.contents}\")\n            elif isinstance(event, ReturnEvent):\n                print(f\"{' ' * (indent)}// {'=' * FUNCTION_DELIMITER_LENGTH}\\n\")\n                indent -= indent_size\n            elif isinstance(event, ExceptionEvent):\n                contents = f\" `{event.exception.__qualname__}` \"\n                print(\n                    f\"\\n{' ' * indent}// !!{contents:{'!'}{'^'}{FUNCTION_DELIMITER_LENGTH - 4}}!!\"\n                )\n            if isinstance(event, OpcodeEvent):\n                curr_instr = \"--&gt;\" if event.curr_instr else \"\"\n                jump = \"&gt;&gt; \" if event.jump else \"\"\n                line_no = event.lineno if event.lineno is not None else \"\"\n                arg = event.arg if event.arg is not None else \"\"\n                line = (\n                    \" \" * indent\n                    + f\"{line_no:&gt;3} {curr_instr:&gt;3} {jump:&gt;3} {event.offset:&lt;3} \"\n                    + f\"{event.opname:&lt;20} {arg:&lt;3} {'(' + event.argrepr + ')'}\"\n                )\n                if elapsed_times is not None:\n                    line += padded_time(line, \"//\", elapsed_times[elapsed_time_index])\n                    elapsed_time_index += 1\n                print(line)\n</code></pre>"},{"location":"reference.html#bytesight.profiler.BytecodeProfiler.profile","title":"<code>profile(func: Callable[..., Any], *args: list[Any], **kwargs: dict[str, Any]) -&gt; None</code>","text":"<p>Collect all events emitted when invoking a function.</p> Source code in <code>src/bytesight/profiler.py</code> <pre><code>def profile(\n    self, func: Callable[..., Any], *args: list[Any], **kwargs: dict[str, Any]\n) -&gt; None:\n    \"\"\"Collect all events emitted when invoking a function.\"\"\"\n    if PYTHON_VERSION.minor &lt; 10:\n        raise RuntimeError(\"Tracing only supported for Python versions &gt;=3.10!\")\n\n    self._reset()\n\n    old_trace = sys.gettrace()\n    gcold = gc.isenabled()\n    gc.disable()\n\n    exception = None\n    try:\n        # Warmup cache/specialising adaptive interpreter/JIT\n        for _ in range(self.num_warmups):\n            try:\n                func(*args, **kwargs)\n            except Exception as _exc:\n                pass\n\n        # Measure the time taken to run the function once without tracing\n        self._uninstrumented_time = 0\n        for _ in range(self.num_repeats):\n            start_timestamp: float | None = None\n            try:\n                start_timestamp = perf_counter()\n                func(*args, **kwargs)\n                finish_timestamp = perf_counter()\n            except Exception as _exc:\n                finish_timestamp = perf_counter()\n            assert start_timestamp is not None\n            self._uninstrumented_time += finish_timestamp - start_timestamp\n        if self.num_repeats != 0:\n            self._uninstrumented_time /= self.num_repeats\n\n        # Trace the function collecting the event data to corrollate\n        try:\n            sys.settrace(self._trace__collect_all_events)\n            func(*args, **kwargs)\n        except Exception as exc:\n            exception = exc\n        finally:\n            sys.settrace(None)\n        self._events.append(StopEvent(exception))\n\n        # Trace the function collecting only the timestamps\n        instrumented_time_repeats: list[float] = []\n        for _ in range(self.num_repeats):\n            start_timestamp: float | None = None\n            try:\n                sys.settrace(self._trace__collect_event_timestamps)\n                start_timestamp = perf_counter()\n                func(*args, **kwargs)\n                finish_timestamp = perf_counter()\n            except Exception as _exc:\n                finish_timestamp = perf_counter()\n            finally:\n                sys.settrace(None)\n            self._timestamps.append((self._prev_event_timestamp, finish_timestamp))\n            assert start_timestamp is not None\n            instrumented_time_repeats.append(finish_timestamp - start_timestamp)\n        if self.num_repeats != 0:\n            self._instrumented_time = statistics.mean(instrumented_time_repeats)\n\n    finally:\n        if gcold:\n            gc.enable()\n        sys.settrace(old_trace)\n        opcode_events = [\n            e\n            for e in self._events\n            if isinstance(e, OpcodeEvent) or isinstance(e, StopEvent)\n        ]\n        assert len(opcode_events) * self.num_repeats == len(self._timestamps)\n</code></pre>"},{"location":"reference.html#bytesight.profiler.BytecodeProfiler.get_nop_sled","title":"<code>get_nop_sled(size: int) -&gt; Callable[..., None]</code>  <code>classmethod</code>","text":"<p>Get a function which is a nop sled for baseline profiling.</p> Source code in <code>src/bytesight/profiler.py</code> <pre><code>@classmethod\ndef get_nop_sled(cls, size: int) -&gt; Callable[..., None]:\n    \"\"\"Get a function which is a nop sled for baseline profiling.\"\"\"\n    many_passes = \"\\n    \".join(\"pass\" for _ in range(size))\n    namespace: dict[str, Any] = {}\n    exec(f\"def nop_sled():\\n    {many_passes}\", {}, namespace)\n    return namespace[\"nop_sled\"]\n</code></pre>"},{"location":"reference.html#bytesight.profiler.BytecodeProfiler.calibrate_opcode_overhead","title":"<code>calibrate_opcode_overhead(num_opcodes: int = 1000) -&gt; None</code>","text":"<p>Calibrate opcode tracing overhead by tracing many NOP opcodes.</p> Source code in <code>src/bytesight/profiler.py</code> <pre><code>def calibrate_opcode_overhead(self, num_opcodes: int = 1000) -&gt; None:\n    \"\"\"Calibrate opcode tracing overhead by tracing many NOP opcodes.\"\"\"\n    nop_sled = self.get_nop_sled(num_opcodes)\n    self.profile(nop_sled)\n    assert self._uninstrumented_time is not None\n    assert self._instrumented_time is not None\n    assert len(self._events)\n    assert isinstance(self._events[-1], StopEvent)\n    assert self._events[-1].exception is None\n\n    elapsed_times = self.calculate_elapsed_times()\n    self._opcode_overhead = (sum(elapsed_times) - self._uninstrumented_time) / len(\n        elapsed_times\n    )\n\n    self._reset()\n</code></pre>"},{"location":"reference.html#bytesight.profiler.BytecodeProfiler.calculate_elapsed_times","title":"<code>calculate_elapsed_times() -&gt; list[float]</code>","text":"<p>Calculate the elapsed time for each event.</p> Source code in <code>src/bytesight/profiler.py</code> <pre><code>def calculate_elapsed_times(self) -&gt; list[float]:\n    \"\"\"Calculate the elapsed time for each event.\"\"\"\n    timestamp_repeats: list[list[EventTimestamp]] = []\n    opcode_events = [\n        e\n        for e in self._events\n        if isinstance(e, OpcodeEvent) or isinstance(e, StopEvent)\n    ]\n    for i in range(0, len(self._timestamps), len(opcode_events)):\n        timestamp_repeats.append(self._timestamps[i : i + len(opcode_events)])\n\n    elapsed_time_repeats: list[list[float]] = []\n    for timestamps in timestamp_repeats:\n        elapsed_times: list[float] = [0.0 for _ in range(len(timestamps))]\n        for i, timestamp in enumerate(timestamps):\n            if i == 0:\n                continue\n            assert (start_execution_timestamp := timestamp[0]) is not None\n            assert (end_execution_timestamp := timestamp[1]) is not None\n            elapsed_times[i - 1] = (\n                end_execution_timestamp\n                - start_execution_timestamp\n                - self._opcode_overhead\n            )\n        elapsed_time_repeats.append(elapsed_times)\n\n    elapsed_times = [\n        # statistics.mean(event_elapsed_times)\n        min(event_elapsed_times)\n        for event_elapsed_times in zip(*elapsed_time_repeats, strict=False)\n    ]\n\n    if self.debug:\n        assert self._uninstrumented_time is not None\n        assert self._instrumented_time is not None\n        print(\"===========================================\")\n        print(f\" Events recorded: {len(self.events)}\")\n        print(f\" Opcodes recorded: {len(elapsed_times)}\")\n        print(f\" Uninstrumented: {self._uninstrumented_time * NS_PER_S:.2f} ns\")\n        print(\n            f\" Uninstrumented per opcode: {(self._uninstrumented_time / len(elapsed_times)) * NS_PER_S:.2f} ns/op\"\n        )\n        print(f\" Instrumented: {self._instrumented_time * NS_PER_S:.2f} ns\")\n        print(\n            f\" Instrumented per opcode: {(self._instrumented_time / len(elapsed_times)) * NS_PER_S:.2f} ns/op\"\n        )\n        print(f\" Elapsed: {sum(elapsed_times) * NS_PER_S:.2f} ns\")\n        print(\n            f\" Elapsed per opcode: {statistics.mean(elapsed_times) * NS_PER_S:.2f} ns/op\"\n        )\n        print(f\" Opcode overhead: {self._opcode_overhead * NS_PER_S:.2f} ns/op\")\n        tracing_overhead = (sum(elapsed_times) - self._uninstrumented_time) / len(\n            elapsed_times\n        )\n        print(\n            f\" Tracing overhead per opcode: {tracing_overhead * NS_PER_S:.2f} ns/op\"\n        )\n        print(\"===========================================\", end=\"\\n\\n\")\n\n    return elapsed_times\n</code></pre>"},{"location":"reference.html#bytesight.profiler.BytecodeProfiler.calculate_trace_times","title":"<code>calculate_trace_times() -&gt; list[float]</code>","text":"<p>Calculate the trace time for each event.</p> Source code in <code>src/bytesight/profiler.py</code> <pre><code>def calculate_trace_times(self) -&gt; list[float]:\n    \"\"\"Calculate the trace time for each event.\"\"\"\n    elapsed_times = self.calculate_elapsed_times()\n    assert self.uninstrumented_time is not None\n    scaling_factor = self.uninstrumented_time / sum(elapsed_times)\n    return [elapsed_time * scaling_factor for elapsed_time in elapsed_times]\n</code></pre>"},{"location":"reference.html#bytesight.profiler.BytecodeProfiler.print_events","title":"<code>print_events(events: list[Any], trace_name: str, elapsed_times: list[float] | None = None, indent_size: int = 4, debug: bool = True) -&gt; None</code>  <code>classmethod</code>","text":"<p>Print a string representation of the traced events.</p> Source code in <code>src/bytesight/profiler.py</code> <pre><code>@classmethod\ndef print_events(\n    cls,\n    events: list[Any],\n    trace_name: str,\n    elapsed_times: list[float] | None = None,\n    indent_size: int = 4,\n    debug: bool = True,\n) -&gt; None:\n    \"\"\"Print a string representation of the traced events.\"\"\"\n    if elapsed_times is not None:\n        assert len(\n            [\n                e\n                for e in events\n                if isinstance(e, OpcodeEvent) or isinstance(e, StopEvent)\n            ]\n        ) == len(elapsed_times)\n\n    print(f\"//// Trace of `{trace_name}` :\")\n    indent = -indent_size\n    elapsed_time_index = 0\n    for i, event in enumerate(events):\n        if isinstance(event, CallEvent):\n            indent += indent_size\n            contents = f\" {event.file.stem}:{event.lineno} `{event.name}` \"\n            print(\n                f\"\\n{' ' * indent}// =={contents:{'='}{'^'}{FUNCTION_DELIMITER_LENGTH - 4}}==\"\n            )\n        elif isinstance(event, LineEvent):\n            print(f\"{' ' * indent}// &gt;&gt;&gt; {event.contents}\")\n        elif isinstance(event, ReturnEvent):\n            print(f\"{' ' * (indent)}// {'=' * FUNCTION_DELIMITER_LENGTH}\\n\")\n            indent -= indent_size\n        elif isinstance(event, ExceptionEvent):\n            contents = f\" `{event.exception.__qualname__}` \"\n            print(\n                f\"\\n{' ' * indent}// !!{contents:{'!'}{'^'}{FUNCTION_DELIMITER_LENGTH - 4}}!!\"\n            )\n        if isinstance(event, OpcodeEvent):\n            curr_instr = \"--&gt;\" if event.curr_instr else \"\"\n            jump = \"&gt;&gt; \" if event.jump else \"\"\n            line_no = event.lineno if event.lineno is not None else \"\"\n            arg = event.arg if event.arg is not None else \"\"\n            line = (\n                \" \" * indent\n                + f\"{line_no:&gt;3} {curr_instr:&gt;3} {jump:&gt;3} {event.offset:&lt;3} \"\n                + f\"{event.opname:&lt;20} {arg:&lt;3} {'(' + event.argrepr + ')'}\"\n            )\n            if elapsed_times is not None:\n                line += padded_time(line, \"//\", elapsed_times[elapsed_time_index])\n                elapsed_time_index += 1\n            print(line)\n</code></pre>"},{"location":"reference.html#bytesight.profiler.round_to_ns_resolution","title":"<code>round_to_ns_resolution(measurement: float, resolution: float = PERF_COUNTER_RESOLUTION) -&gt; float</code>","text":"<p>Round a floating point value to a resolution.</p> Source code in <code>src/bytesight/profiler.py</code> <pre><code>def round_to_ns_resolution(\n    measurement: float, resolution: float = PERF_COUNTER_RESOLUTION\n) -&gt; float:\n    \"\"\"Round a floating point value to a resolution.\"\"\"\n    if resolution == 0:\n        return measurement * NS_PER_S\n\n    factor = 10 ** math.floor(math.log10(resolution * NS_PER_S))\n    return round(measurement * NS_PER_S / factor) * factor\n</code></pre>"},{"location":"reference.html#bytesight.profiler.padded_time","title":"<code>padded_time(message: str, prefix: str, elapsed: float) -&gt; str</code>","text":"<p>Get a padded string containing the time for a trace event.</p> Source code in <code>src/bytesight/profiler.py</code> <pre><code>def padded_time(message: str, prefix: str, elapsed: float) -&gt; str:\n    \"\"\"Get a padded string containing the time for a trace event.\"\"\"\n    return (\n        \" \" * max(1, MIN_TIME_PADDING - len(message))\n        + prefix\n        + f\" {round_to_ns_resolution(elapsed):&lt;4} ns\"\n    )\n</code></pre>"}]}